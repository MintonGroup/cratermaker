<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Surface - CraterMaker Documentation</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">CraterMaker Documentation</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../cratermaker_overview/" class="nav-link">Overview</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">API Reference <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../crater/" class="dropdown-item">Crater</a>
</li>
                                    
<li>
    <a href="../morphology/" class="dropdown-item">Morphology</a>
</li>
                                    
<li>
    <a href="../production/" class="dropdown-item">Production</a>
</li>
                                    
<li>
    <a href="../scale/" class="dropdown-item">Scale</a>
</li>
                                    
<li>
    <a href="../simulation/" class="dropdown-item">Simulation</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Surface</a>
</li>
                                    
<li>
    <a href="../target/" class="dropdown-item">Target</a>
</li>
                                    
<li>
    <a href="../general_utils/" class="dropdown-item">General Utilities</a>
</li>
                                    
<li>
    <a href="../montecarlo/" class="dropdown-item">Monte Carlo Utilities</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../license/" class="nav-link">License</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../simulation/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../target/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#surface-module" class="nav-link">Surface Module</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#cratermaker.core.surface" class="nav-link">surface</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cratermaker.core.surface.Surface" class="nav-link">Surface</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cratermaker.core.surface.generate_data" class="nav-link">generate_data()</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cratermaker.core.surface.generate_grid" class="nav-link">generate_grid()</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cratermaker.core.surface.initialize_surface" class="nav-link">initialize_surface()</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cratermaker.core.surface.save_surface" class="nav-link">save_surface()</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="surface-module">Surface Module</h1>


<div class="doc doc-object doc-module">



<a id="cratermaker.core.surface"></a>
  <div class="doc doc-contents first">

  

  <div class="doc doc-children">








<div class="doc doc-object doc-class">




<h2 id="cratermaker.core.surface.Surface" class="doc doc-heading">
          <code>Surface</code>


</h2>


  <div class="doc doc-contents ">
          <p class="doc doc-class-bases">
            Bases: <code><span title="uxarray.UxDataset">UxDataset</span></code></p>

  
      <p>Surface class that extends UxDataset for cratermaker project.</p>
<p>This class is used for handling surface-related data and operations in the 
cratermaker project. It provides functionalities for setting elevation data, 
calculating distances and bearings, and other surface-related computations.</p>
<h4 id="cratermaker.core.surface.Surface--attributes">Attributes</h4>
<p>grid_temp_dir : str
    Directory for temporary grid files.
data_dir : str
    Directory for data files.
grid_file : str
    Path to the grid file.
elevation_file : str
    Path to the node elevation file.
target_radius : str
    Radius of the target body.
pix : FloatLike
    Approximate pixel size or resolution used to generate the mesh.
grid_type : str
    Type of the grid used.</p>
<h4 id="cratermaker.core.surface.Surface--methods">Methods</h4>
<p>set_elevation(new_elev=None)
    Set elevation data for the target's surface mesh.
calculate_haversine_distance(lon1, lat1, lon2, lat2, radius)
    Calculate the great circle distance between two points on a sphere.
get_face_distance(location)
    Computes the distances between cell centers and a given location.
get_node_distance(location)
    Computes the distances between nodes and a given location.
calculate_initial_bearing(lon1, lat1, lon2, lat2)
    Calculate the initial bearing from one point to another on the surface of a sphere.
get_face_initial_bearing(location)
    Computes the initial bearing between cell centers and a given location.
get_node_initial_bearing(location)
    Computes the initial bearing between nodes and a given location.
get_average_surface(location, radius)
    Calculate the orientation of a hemispherical cap that represents the average surface within a given region.</p>

            <details class="quote">
              <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Surface</span><span class="p">(</span><span class="n">UxDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Surface class that extends UxDataset for cratermaker project.</span>

<span class="sd">    This class is used for handling surface-related data and operations in the </span>
<span class="sd">    cratermaker project. It provides functionalities for setting elevation data, </span>
<span class="sd">    calculating distances and bearings, and other surface-related computations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    grid_temp_dir : str</span>
<span class="sd">        Directory for temporary grid files.</span>
<span class="sd">    data_dir : str</span>
<span class="sd">        Directory for data files.</span>
<span class="sd">    grid_file : str</span>
<span class="sd">        Path to the grid file.</span>
<span class="sd">    elevation_file : str</span>
<span class="sd">        Path to the node elevation file.</span>
<span class="sd">    target_radius : str</span>
<span class="sd">        Radius of the target body.</span>
<span class="sd">    pix : FloatLike</span>
<span class="sd">        Approximate pixel size or resolution used to generate the mesh.</span>
<span class="sd">    grid_type : str</span>
<span class="sd">        Type of the grid used.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    set_elevation(new_elev=None)</span>
<span class="sd">        Set elevation data for the target&#39;s surface mesh.</span>
<span class="sd">    calculate_haversine_distance(lon1, lat1, lon2, lat2, radius)</span>
<span class="sd">        Calculate the great circle distance between two points on a sphere.</span>
<span class="sd">    get_face_distance(location)</span>
<span class="sd">        Computes the distances between cell centers and a given location.</span>
<span class="sd">    get_node_distance(location)</span>
<span class="sd">        Computes the distances between nodes and a given location.</span>
<span class="sd">    calculate_initial_bearing(lon1, lat1, lon2, lat2)</span>
<span class="sd">        Calculate the initial bearing from one point to another on the surface of a sphere.</span>
<span class="sd">    get_face_initial_bearing(location)</span>
<span class="sd">        Computes the initial bearing between cell centers and a given location.</span>
<span class="sd">    get_node_initial_bearing(location)</span>
<span class="sd">        Computes the initial bearing between nodes and a given location.</span>
<span class="sd">    get_average_surface(location, radius)</span>
<span class="sd">        Calculate the orientation of a hemispherical cap that represents the average surface within a given region.</span>
<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="n">UxDataset</span><span class="o">.</span><span class="vm">__slots__</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_description&#39;</span><span class="p">,</span><span class="s1">&#39;grid_temp_dir&#39;</span><span class="p">,</span><span class="s1">&#39;data_dir&#39;</span><span class="p">,</span><span class="s1">&#39;grid_file&#39;</span><span class="p">,</span><span class="s1">&#39;elevation_file&#39;</span><span class="p">,</span><span class="s1">&#39;target_radius&#39;</span><span class="p">,</span> <span class="s1">&#39;pix&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_type&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Surface class for cratermaker&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Call the super class constructor with the dataset</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Additional initialization for Surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;Surface&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_description</span> <span class="o">=</span> <span class="s2">&quot;Surface class for cratermaker&quot;</span>



    <span class="k">def</span> <span class="nf">set_elevation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                      <span class="n">new_elev</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="n">FloatLike</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">save_to_file</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set elevation data for the target&#39;s surface mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_elev : array_like, optional</span>
<span class="sd">            New elevation data to be set. If None, the elevation is set to zero. </span>
<span class="sd">        save_to_file : bool, default False</span>
<span class="sd">            If True, save the elevation data to the elevation file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_elev</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">new_elev</span><span class="p">)</span> <span class="ow">or</span> <span class="n">new_elev</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">n_node</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;elevation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_data</span><span class="p">(</span><span class="n">grid_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_file</span><span class="p">,</span>
                                                           <span class="n">data_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">elevation_file</span><span class="p">,</span>
                                                           <span class="n">data</span><span class="o">=</span><span class="n">new_elev</span><span class="p">,</span> 
                                                           <span class="n">name</span><span class="o">=</span><span class="s2">&quot;elevation&quot;</span><span class="p">,</span>
                                                           <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;elevation of nodes&quot;</span><span class="p">,</span>
                                                           <span class="n">isfacedata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                           <span class="n">save_to_file</span><span class="o">=</span><span class="n">save_to_file</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_elev must be None, a scalar, or an array with the same size as the number of nodes in the grid&quot;</span><span class="p">)</span>

        <span class="k">return</span> 


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                    <span class="n">lat1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                    <span class="n">lon2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                    <span class="n">lat2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span>
                    <span class="n">radius</span><span class="p">:</span> <span class="n">FloatLike</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the great circle distance between two points on a sphere.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon1 : FloatLike</span>
<span class="sd">            Longitude of the first point in radians.</span>
<span class="sd">        lat1 : FloatLike</span>
<span class="sd">            Latitude of the first point in radians.</span>
<span class="sd">        lon2 : FloatLike</span>
<span class="sd">            Longitude of the second point in radians.</span>
<span class="sd">        lat2 : FloatLike</span>
<span class="sd">            Latitude of the second point in radians.</span>
<span class="sd">        radius : FloatLike</span>
<span class="sd">            Radius of the sphere in meters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.float64</span>
<span class="sd">            Great circle distance between the two points in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate differences in coordinates</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
        <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>

        <span class="c1"># Haversine formula</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">c</span>


    <span class="k">def</span> <span class="nf">get_face_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                        <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distances between cell centers and a given location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location : Tuple[np.float64, np.float64]</span>
<span class="sd">            Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UxArray.UxDataArray</span>
<span class="sd">            DataArray of distances for each cell in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lon</span><span class="p">)</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target_radius</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_node_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                        <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distances between nodes and a given location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location : Tuple[np.float64, np.float64]</span>
<span class="sd">            Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        UxArray.UxDataArray</span>
<span class="sd">            DataArray of distances for each cell in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lon</span><span class="p">)</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lat</span><span class="p">)</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target_radius</span><span class="p">)</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                                <span class="n">lat1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                                <span class="n">lon2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                                <span class="n">lat2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the initial bearing from one point to another on the surface of a sphere.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lon1 : FloatLike</span>
<span class="sd">            Longitude of the first point in radians.</span>
<span class="sd">        lat1 : FloatLike</span>
<span class="sd">            Latitude of the first point in radians.</span>
<span class="sd">        lon2 : FloatLike</span>
<span class="sd">            Longitude of the second point in radians.</span>
<span class="sd">        lat2 : FloatLike</span>
<span class="sd">            Latitude of the second point in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.float64</span>
<span class="sd">            Initial bearing from the first point to the second point in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate differences in coordinates</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># Haversine formula calculations</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dlon</span><span class="p">)</span>
        <span class="n">initial_bearing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Normalize bearing to 0 to 2*pi</span>
        <span class="n">initial_bearing</span> <span class="o">=</span> <span class="p">(</span><span class="n">initial_bearing</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">initial_bearing</span>


    <span class="k">def</span> <span class="nf">get_face_initial_bearing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the initial bearing between cell centers and a given location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location : Tuple[np.float64, np.float64]</span>
<span class="sd">            Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            DataArray of initial bearings for each cell in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lon</span><span class="p">)</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lat</span><span class="p">)</span>        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_node_initial_bearing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the initial bearing between nodes and a given location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location : Tuple[np.float64, np.float64]</span>
<span class="sd">            Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            DataArray of initial bearings for each cell in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lon</span><span class="p">)</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lat</span><span class="p">)</span>             
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">)</span>  


    <span class="c1"># Function to find nearest cell index</span>
    <span class="k">def</span> <span class="nf">find_nearest_node_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the index of the nearest node to a given point.</span>

<span class="sd">        This method calculates the Haversine distance from the given point to each node in the grid,</span>
<span class="sd">        and returns the index of the node with the minimum distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : tuple</span>
<span class="sd">            A tuple containing two elements: (longitude, latitude) in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index of the nearest node in the grid to the given point.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method converts the longitude and latitude values from degrees to radians before</span>
<span class="sd">        calculating distances. The Haversine formula is used to compute the distances on the</span>
<span class="sd">        surface of a sphere with a radius of 1.0 unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lon</span><span class="p">)</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lat</span><span class="p">)</span>        
        <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>    


    <span class="k">def</span> <span class="nf">find_nearest_face_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the index of the nearest face to a given point.</span>

<span class="sd">        This method calculates the Haversine distance from the given point to each face in the grid,</span>
<span class="sd">        and returns the index of the face with the minimum distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : tuple</span>
<span class="sd">            A tuple containing two elements: (longitude, latitude) in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index of the nearest face in the grid to the given point.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The method converts the longitude and latitude values from degrees to radians before</span>
<span class="sd">        calculating distances. The Haversine formula is used to compute the distances on the</span>
<span class="sd">        surface of a sphere with a radius of 1.0 unit. This method differs from `find_nearest_node_index`</span>
<span class="sd">        in that it considers the grid&#39;s faces instead of its nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lon</span><span class="p">)</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lat</span><span class="p">)</span>        
        <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>   


    <span class="k">def</span> <span class="nf">get_average_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FloatLike</span><span class="p">,</span> <span class="n">FloatLike</span><span class="p">],</span> 
                            <span class="n">radius</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the orientation of a hemispherical cap that represents the average surface within a given region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        location : Tuple[float, float]</span>
<span class="sd">            Tuple containing the longitude and latitude of the reference location in radians.</span>
<span class="sd">        radius : float</span>
<span class="sd">            The reference radius of to compute the average over in meters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center_vector : ndarray</span>
<span class="sd">            The vector pointing to the center of the cap from the sphere&#39;s center.</span>
<span class="sd">        radius : float</span>
<span class="sd">            The radius of the cap.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find cells within the crater radius</span>
        <span class="c1"># cells_within_radius = data[&#39;crater_distance&#39;] &lt;= radius</span>

        <span class="c1"># bearings = data[&#39;crater_bearing&#39;].where(cells_within_radius, drop=True)</span>
        <span class="c1"># distances = data[&#39;crater_distance&#39;].where(cells_within_radius, drop=True)</span>

        <span class="c1"># # Convert bearings to vector components</span>
        <span class="c1"># # Bearing is angle from north, positive clockwise, but we need standard mathematical angle, positive counter-clockwise</span>
        <span class="c1"># angles = np.deg2rad(90) - bearings  # Convert bearing to angle in radians</span>
        <span class="c1"># x_components = np.cos(angles) * distances</span>
        <span class="c1"># y_components = np.sin(angles) * distances</span>

        <span class="c1"># # Calculate the weighted average vector components</span>
        <span class="c1"># # Weight by the area of each cell to give more importance to larger cells</span>
        <span class="c1"># cell_areas = mesh[&#39;areaCell&#39;].where(cells_within_radius, drop=True)</span>
        <span class="c1"># weighted_x = (x_components * cell_areas).sum() / cell_areas.sum()</span>
        <span class="c1"># weighted_y = (y_components * cell_areas).sum() / cell_areas.sum()</span>

        <span class="c1"># # Calculate the weighted mean elevation to get the z-component</span>
        <span class="c1"># elevation_values = data[&#39;elevation&#39;].where(cells_within_radius, drop=True)</span>
        <span class="c1"># weighted_z = (elevation_values * cell_areas).sum() / cell_areas.sum()</span>

        <span class="c1"># # Combine components to form the cap center vector</span>
        <span class="c1"># center_vector = -np.array([weighted_x.item(), weighted_y.item(), weighted_z.item()])</span>

        <span class="c1"># # The radius of the cap is the length of the cap center vector</span>
        <span class="c1"># radius = np.linalg.norm(center_vector)</span>
        <span class="n">center_vector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">center_vector</span> 
</code></pre></div></td></tr></table></div>
            </details>

  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">




<h3 id="cratermaker.core.surface.Surface.__slots__" class="doc doc-heading">
          <code class="highlight language-python"><span class="vm">__slots__</span> <span class="o">=</span> <span class="n">UxDataset</span><span class="o">.</span><span class="vm">__slots__</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_description&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_temp_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;data_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_file&#39;</span><span class="p">,</span> <span class="s1">&#39;elevation_file&#39;</span><span class="p">,</span> <span class="s1">&#39;target_radius&#39;</span><span class="p">,</span> <span class="s1">&#39;pix&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_type&#39;</span><span class="p">)</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Surface class for cratermaker</p>
  </div>

</div>




<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.calculate_haversine_distance" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculate the great circle distance between two points on a sphere.</p>
<h5 id="cratermaker.core.surface.Surface.calculate_haversine_distance--parameters">Parameters</h5>
<p>lon1 : FloatLike
    Longitude of the first point in radians.
lat1 : FloatLike
    Latitude of the first point in radians.
lon2 : FloatLike
    Longitude of the second point in radians.
lat2 : FloatLike
    Latitude of the second point in radians.
radius : FloatLike
    Radius of the sphere in meters.</p>
<h5 id="cratermaker.core.surface.Surface.calculate_haversine_distance--returns">Returns</h5>
<p>np.float64
    Great circle distance between the two points in meters.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                <span class="n">lat1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                <span class="n">lon2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                <span class="n">lat2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span>
                <span class="n">radius</span><span class="p">:</span> <span class="n">FloatLike</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the great circle distance between two points on a sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon1 : FloatLike</span>
<span class="sd">        Longitude of the first point in radians.</span>
<span class="sd">    lat1 : FloatLike</span>
<span class="sd">        Latitude of the first point in radians.</span>
<span class="sd">    lon2 : FloatLike</span>
<span class="sd">        Longitude of the second point in radians.</span>
<span class="sd">    lat2 : FloatLike</span>
<span class="sd">        Latitude of the second point in radians.</span>
<span class="sd">    radius : FloatLike</span>
<span class="sd">        Radius of the sphere in meters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.float64</span>
<span class="sd">        Great circle distance between the two points in meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate differences in coordinates</span>
    <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>

    <span class="c1"># Haversine formula</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">c</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.calculate_initial_bearing" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">)</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculate the initial bearing from one point to another on the surface of a sphere.</p>
<h5 id="cratermaker.core.surface.Surface.calculate_initial_bearing--parameters">Parameters</h5>
<p>lon1 : FloatLike
    Longitude of the first point in radians.
lat1 : FloatLike
    Latitude of the first point in radians.
lon2 : FloatLike
    Longitude of the second point in radians.
lat2 : FloatLike
    Latitude of the second point in radians.</p>
<h5 id="cratermaker.core.surface.Surface.calculate_initial_bearing--returns">Returns</h5>
<p>np.float64
    Initial bearing from the first point to the second point in radians.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                            <span class="n">lat1</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                            <span class="n">lon2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                            <span class="n">lat2</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the initial bearing from one point to another on the surface of a sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon1 : FloatLike</span>
<span class="sd">        Longitude of the first point in radians.</span>
<span class="sd">    lat1 : FloatLike</span>
<span class="sd">        Latitude of the first point in radians.</span>
<span class="sd">    lon2 : FloatLike</span>
<span class="sd">        Longitude of the second point in radians.</span>
<span class="sd">    lat2 : FloatLike</span>
<span class="sd">        Latitude of the second point in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.float64</span>
<span class="sd">        Initial bearing from the first point to the second point in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate differences in coordinates</span>
    <span class="n">dlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># Haversine formula calculations</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dlon</span><span class="p">)</span>
    <span class="n">initial_bearing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># Normalize bearing to 0 to 2*pi</span>
    <span class="n">initial_bearing</span> <span class="o">=</span> <span class="p">(</span><span class="n">initial_bearing</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">initial_bearing</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.find_nearest_face_index" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">find_nearest_face_index</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Find the index of the nearest face to a given point.</p>
<p>This method calculates the Haversine distance from the given point to each face in the grid,
and returns the index of the face with the minimum distance.</p>
<h5 id="cratermaker.core.surface.Surface.find_nearest_face_index--parameters">Parameters</h5>
<p>point : tuple
    A tuple containing two elements: (longitude, latitude) in degrees.</p>
<h5 id="cratermaker.core.surface.Surface.find_nearest_face_index--returns">Returns</h5>
<p>int
    The index of the nearest face in the grid to the given point.</p>
<h5 id="cratermaker.core.surface.Surface.find_nearest_face_index--notes">Notes</h5>
<p>The method converts the longitude and latitude values from degrees to radians before
calculating distances. The Haversine formula is used to compute the distances on the
surface of a sphere with a radius of 1.0 unit. This method differs from <code>find_nearest_node_index</code>
in that it considers the grid's faces instead of its nodes.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">find_nearest_face_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the index of the nearest face to a given point.</span>

<span class="sd">    This method calculates the Haversine distance from the given point to each face in the grid,</span>
<span class="sd">    and returns the index of the face with the minimum distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point : tuple</span>
<span class="sd">        A tuple containing two elements: (longitude, latitude) in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The index of the nearest face in the grid to the given point.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The method converts the longitude and latitude values from degrees to radians before</span>
<span class="sd">    calculating distances. The Haversine formula is used to compute the distances on the</span>
<span class="sd">    surface of a sphere with a radius of 1.0 unit. This method differs from `find_nearest_node_index`</span>
<span class="sd">    in that it considers the grid&#39;s faces instead of its nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>        
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lon</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lat</span><span class="p">)</span>        
    <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>   
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.find_nearest_node_index" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">find_nearest_node_index</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Find the index of the nearest node to a given point.</p>
<p>This method calculates the Haversine distance from the given point to each node in the grid,
and returns the index of the node with the minimum distance.</p>
<h5 id="cratermaker.core.surface.Surface.find_nearest_node_index--parameters">Parameters</h5>
<p>point : tuple
    A tuple containing two elements: (longitude, latitude) in degrees.</p>
<h5 id="cratermaker.core.surface.Surface.find_nearest_node_index--returns">Returns</h5>
<p>int
    The index of the nearest node in the grid to the given point.</p>
<h5 id="cratermaker.core.surface.Surface.find_nearest_node_index--notes">Notes</h5>
<p>The method converts the longitude and latitude values from degrees to radians before
calculating distances. The Haversine formula is used to compute the distances on the
surface of a sphere with a radius of 1.0 unit.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">find_nearest_node_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the index of the nearest node to a given point.</span>

<span class="sd">    This method calculates the Haversine distance from the given point to each node in the grid,</span>
<span class="sd">    and returns the index of the node with the minimum distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    point : tuple</span>
<span class="sd">        A tuple containing two elements: (longitude, latitude) in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The index of the nearest node in the grid to the given point.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The method converts the longitude and latitude values from degrees to radians before</span>
<span class="sd">    calculating distances. The Haversine formula is used to compute the distances on the</span>
<span class="sd">    surface of a sphere with a radius of 1.0 unit.</span>
<span class="sd">    &quot;&quot;&quot;</span>        
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lon</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lat</span><span class="p">)</span>        
    <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>    
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.get_average_surface" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_average_surface</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Calculate the orientation of a hemispherical cap that represents the average surface within a given region.</p>
<h5 id="cratermaker.core.surface.Surface.get_average_surface--parameters">Parameters</h5>
<p>location : Tuple[float, float]
    Tuple containing the longitude and latitude of the reference location in radians.
radius : float
    The reference radius of to compute the average over in meters.</p>
<h5 id="cratermaker.core.surface.Surface.get_average_surface--returns">Returns</h5>
<p>center_vector : ndarray
    The vector pointing to the center of the cap from the sphere's center.
radius : float
    The radius of the cap.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_average_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FloatLike</span><span class="p">,</span> <span class="n">FloatLike</span><span class="p">],</span> 
                        <span class="n">radius</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the orientation of a hemispherical cap that represents the average surface within a given region.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    location : Tuple[float, float]</span>
<span class="sd">        Tuple containing the longitude and latitude of the reference location in radians.</span>
<span class="sd">    radius : float</span>
<span class="sd">        The reference radius of to compute the average over in meters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    center_vector : ndarray</span>
<span class="sd">        The vector pointing to the center of the cap from the sphere&#39;s center.</span>
<span class="sd">    radius : float</span>
<span class="sd">        The radius of the cap.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find cells within the crater radius</span>
    <span class="c1"># cells_within_radius = data[&#39;crater_distance&#39;] &lt;= radius</span>

    <span class="c1"># bearings = data[&#39;crater_bearing&#39;].where(cells_within_radius, drop=True)</span>
    <span class="c1"># distances = data[&#39;crater_distance&#39;].where(cells_within_radius, drop=True)</span>

    <span class="c1"># # Convert bearings to vector components</span>
    <span class="c1"># # Bearing is angle from north, positive clockwise, but we need standard mathematical angle, positive counter-clockwise</span>
    <span class="c1"># angles = np.deg2rad(90) - bearings  # Convert bearing to angle in radians</span>
    <span class="c1"># x_components = np.cos(angles) * distances</span>
    <span class="c1"># y_components = np.sin(angles) * distances</span>

    <span class="c1"># # Calculate the weighted average vector components</span>
    <span class="c1"># # Weight by the area of each cell to give more importance to larger cells</span>
    <span class="c1"># cell_areas = mesh[&#39;areaCell&#39;].where(cells_within_radius, drop=True)</span>
    <span class="c1"># weighted_x = (x_components * cell_areas).sum() / cell_areas.sum()</span>
    <span class="c1"># weighted_y = (y_components * cell_areas).sum() / cell_areas.sum()</span>

    <span class="c1"># # Calculate the weighted mean elevation to get the z-component</span>
    <span class="c1"># elevation_values = data[&#39;elevation&#39;].where(cells_within_radius, drop=True)</span>
    <span class="c1"># weighted_z = (elevation_values * cell_areas).sum() / cell_areas.sum()</span>

    <span class="c1"># # Combine components to form the cap center vector</span>
    <span class="c1"># center_vector = -np.array([weighted_x.item(), weighted_y.item(), weighted_z.item()])</span>

    <span class="c1"># # The radius of the cap is the length of the cap center vector</span>
    <span class="c1"># radius = np.linalg.norm(center_vector)</span>
    <span class="n">center_vector</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">center_vector</span> 
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.get_face_distance" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_face_distance</span><span class="p">(</span><span class="n">location</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the distances between cell centers and a given location.</p>
<h5 id="cratermaker.core.surface.Surface.get_face_distance--parameters">Parameters</h5>
<p>location : Tuple[np.float64, np.float64]
    Tuple containing the longitude and latitude of the location in radians.</p>
<h5 id="cratermaker.core.surface.Surface.get_face_distance--returns">Returns</h5>
<p>UxArray.UxDataArray
    DataArray of distances for each cell in meters.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_face_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                    <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the distances between cell centers and a given location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    location : Tuple[np.float64, np.float64]</span>
<span class="sd">        Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    UxArray.UxDataArray</span>
<span class="sd">        DataArray of distances for each cell in meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lon</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lat</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target_radius</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.get_face_initial_bearing" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_face_initial_bearing</span><span class="p">(</span><span class="n">location</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the initial bearing between cell centers and a given location.</p>
<h5 id="cratermaker.core.surface.Surface.get_face_initial_bearing--parameters">Parameters</h5>
<p>location : Tuple[np.float64, np.float64]
    Tuple containing the longitude and latitude of the location in radians.</p>
<h5 id="cratermaker.core.surface.Surface.get_face_initial_bearing--returns">Returns</h5>
<p>xarray.DataArray
    DataArray of initial bearings for each cell in radians.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_face_initial_bearing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the initial bearing between cell centers and a given location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    location : Tuple[np.float64, np.float64]</span>
<span class="sd">        Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xarray.DataArray</span>
<span class="sd">        DataArray of initial bearings for each cell in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lon</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">face_lat</span><span class="p">)</span>        
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.get_node_distance" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_node_distance</span><span class="p">(</span><span class="n">location</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the distances between nodes and a given location.</p>
<h5 id="cratermaker.core.surface.Surface.get_node_distance--parameters">Parameters</h5>
<p>location : Tuple[np.float64, np.float64]
    Tuple containing the longitude and latitude of the location in radians.</p>
<h5 id="cratermaker.core.surface.Surface.get_node_distance--returns">Returns</h5>
<p>UxArray.UxDataArray
    DataArray of distances for each cell in meters.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_node_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                    <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the distances between nodes and a given location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    location : Tuple[np.float64, np.float64]</span>
<span class="sd">        Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    UxArray.UxDataArray</span>
<span class="sd">        DataArray of distances for each cell in meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lon</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lat</span><span class="p">)</span>        
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_haversine_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target_radius</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.get_node_initial_bearing" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">get_node_initial_bearing</span><span class="p">(</span><span class="n">location</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Computes the initial bearing between nodes and a given location.</p>
<h5 id="cratermaker.core.surface.Surface.get_node_initial_bearing--parameters">Parameters</h5>
<p>location : Tuple[np.float64, np.float64]
    Tuple containing the longitude and latitude of the location in radians.</p>
<h5 id="cratermaker.core.surface.Surface.get_node_initial_bearing--returns">Returns</h5>
<p>xarray.DataArray
    DataArray of initial bearings for each cell in radians.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_node_initial_bearing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the initial bearing between nodes and a given location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    location : Tuple[np.float64, np.float64]</span>
<span class="sd">        Tuple containing the longitude and latitude of the location in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xarray.DataArray</span>
<span class="sd">        DataArray of initial bearings for each cell in radians.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lon</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">node_lat</span><span class="p">)</span>             
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_initial_bearing</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">)</span>  
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h3 id="cratermaker.core.surface.Surface.set_elevation" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">set_elevation</span><span class="p">(</span><span class="n">new_elev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Set elevation data for the target's surface mesh.</p>
<h5 id="cratermaker.core.surface.Surface.set_elevation--parameters">Parameters</h5>
<p>new_elev : array_like, optional
    New elevation data to be set. If None, the elevation is set to zero. 
save_to_file : bool, default False
    If True, save the elevation data to the elevation file.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set_elevation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                  <span class="n">new_elev</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="n">FloatLike</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">save_to_file</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set elevation data for the target&#39;s surface mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    new_elev : array_like, optional</span>
<span class="sd">        New elevation data to be set. If None, the elevation is set to zero. </span>
<span class="sd">    save_to_file : bool, default False</span>
<span class="sd">        If True, save the elevation data to the elevation file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">new_elev</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">new_elev</span><span class="p">)</span> <span class="ow">or</span> <span class="n">new_elev</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">uxgrid</span><span class="o">.</span><span class="n">n_node</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;elevation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generate_data</span><span class="p">(</span><span class="n">grid_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_file</span><span class="p">,</span>
                                                       <span class="n">data_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">elevation_file</span><span class="p">,</span>
                                                       <span class="n">data</span><span class="o">=</span><span class="n">new_elev</span><span class="p">,</span> 
                                                       <span class="n">name</span><span class="o">=</span><span class="s2">&quot;elevation&quot;</span><span class="p">,</span>
                                                       <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;elevation of nodes&quot;</span><span class="p">,</span>
                                                       <span class="n">isfacedata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">save_to_file</span><span class="o">=</span><span class="n">save_to_file</span><span class="p">)</span>            
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_elev must be None, a scalar, or an array with the same size as the number of nodes in the grid&quot;</span><span class="p">)</span>

    <span class="k">return</span> 
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>



  </div>

  </div>

</div>



<div class="doc doc-object doc-function">




<h2 id="cratermaker.core.surface.generate_data" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">generate_data</span><span class="p">(</span><span class="n">grid_file</span><span class="p">,</span> <span class="n">data_file</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">long_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isfacedata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Generate a NetCDF data file using the provided grid file and save it to the specified path.</p>
<h4 id="cratermaker.core.surface.generate_data--parameters">Parameters</h4>
<p>data_file : os.PathLike
    Path where the grid file will be saved.
grid_file : os.PathLike
    Path where the grid file can be found.
name : str
    Name of the data variable.
long_name : str, optional
    Long name of the data variable that will be saved as an attribute.
data : scalar or array-like
    Data file to be saved. If data is a scalar, then the data file will be filled with that value. If data is an array, then the data file will be filled with the array values. The data array must have the same size as the number of faces or nodes in the grid.
isfacedata : bool, optional
    Flag to indicate whether the data is face data or node data. Default is True.
save_to_file: bool, optional
    Specify whether the data should be saved to a file. Default is False.
Returns</p>
<hr />
<p>None</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">generate_data</span><span class="p">(</span><span class="n">grid_file</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">,</span>
                  <span class="n">data_file</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">,</span>
                  <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                  <span class="n">long_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">data</span><span class="p">:</span> <span class="n">FloatLike</span> <span class="o">|</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">isfacedata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">save_to_file</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a NetCDF data file using the provided grid file and save it to the specified path.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_file : os.PathLike</span>
<span class="sd">        Path where the grid file will be saved.</span>
<span class="sd">    grid_file : os.PathLike</span>
<span class="sd">        Path where the grid file can be found.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the data variable.</span>
<span class="sd">    long_name : str, optional</span>
<span class="sd">        Long name of the data variable that will be saved as an attribute.</span>
<span class="sd">    data : scalar or array-like</span>
<span class="sd">        Data file to be saved. If data is a scalar, then the data file will be filled with that value. If data is an array, then the data file will be filled with the array values. The data array must have the same size as the number of faces or nodes in the grid.</span>
<span class="sd">    isfacedata : bool, optional</span>
<span class="sd">        Flag to indicate whether the data is face data or node data. Default is True.</span>
<span class="sd">    save_to_file: bool, optional</span>
<span class="sd">        Specify whether the data should be saved to a file. Default is False.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">uxgrid</span> <span class="o">=</span> <span class="n">uxr</span><span class="o">.</span><span class="n">open_grid</span><span class="p">(</span><span class="n">grid_file</span><span class="p">,</span><span class="n">latlon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">use_dual</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isfacedata</span><span class="p">:</span> 
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_face&quot;</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">uxgrid</span><span class="o">.</span><span class="n">n_face</span>
        <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n_face&#39;</span><span class="p">:</span> <span class="s1">&#39;nCells&#39;</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_node&quot;</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">uxgrid</span><span class="o">.</span><span class="n">n_node</span>
        <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n_node&#39;</span><span class="p">:</span> <span class="s1">&#39;nVertices&#39;</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data must have the same size as the number of faces or nodes in the grid&quot;</span><span class="p">)</span> 
    <span class="n">uxda</span> <span class="o">=</span> <span class="n">uxr</span><span class="o">.</span><span class="n">UxDataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">long_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{</span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="n">long_name</span><span class="p">},</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">uxgrid</span><span class="o">=</span><span class="n">uxgrid</span>
            <span class="p">)</span> 
    <span class="k">if</span> <span class="n">save_to_file</span><span class="p">:</span>
        <span class="n">uxda</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">data_file</span><span class="p">)</span> 
        <span class="n">uxda</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">uxda</span> 
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h2 id="cratermaker.core.surface.generate_grid" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">generate_grid</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pix</span><span class="p">,</span> <span class="n">grid_file</span><span class="p">,</span> <span class="n">grid_temp_dir</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Generate a tessellated mesh of a sphere using the jigsaw-based mesh builder in MPAS-tools.</p>
<p>This function generates temporary files in the <code>grid_temp_dir</code> directory and saves the final mesh to <code>grid_file</code>.</p>
<h4 id="cratermaker.core.surface.generate_grid--parameters">Parameters</h4>
<p>target : str or Target
    Name of target body or a Target object
pix : FloatLike
    Desired cell size for the mesh.
grid_file : os.PathLike
    Path where the grid file will be saved.
grid_temp_dir : os.PathLike
    Path to the directory for storing temporary grid files.</p>
<h4 id="cratermaker.core.surface.generate_grid--returns">Returns</h4>
<p>A cratermaker Surface object with the generated grid as the uxgrid attribute and with an elevation variable set to zero.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">generate_grid</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="n">Target</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> 
                <span class="n">pix</span><span class="p">:</span> <span class="n">FloatLike</span><span class="p">,</span> 
                <span class="n">grid_file</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">,</span>
                <span class="n">grid_temp_dir</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">)</span>  <span class="o">-&gt;</span> <span class="n">Surface</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a tessellated mesh of a sphere using the jigsaw-based mesh builder in MPAS-tools.</span>

<span class="sd">    This function generates temporary files in the `grid_temp_dir` directory and saves the final mesh to `grid_file`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target : str or Target</span>
<span class="sd">        Name of target body or a Target object</span>
<span class="sd">    pix : FloatLike</span>
<span class="sd">        Desired cell size for the mesh.</span>
<span class="sd">    grid_file : os.PathLike</span>
<span class="sd">        Path where the grid file will be saved.</span>
<span class="sd">    grid_temp_dir : os.PathLike</span>
<span class="sd">        Path to the directory for storing temporary grid files.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A cratermaker Surface object with the generated grid as the uxgrid attribute and with an elevation variable set to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">Target</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid target name </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Target</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;target must be an instance of Target or a valid name of a target body&quot;</span><span class="p">)</span>

    <span class="n">cellWidth</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">_make_uniform_face_size</span><span class="p">(</span><span class="n">pix</span><span class="p">)</span>
    <span class="n">orig_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">grid_temp_dir</span><span class="p">)</span>
    <span class="c1"># Configure logger to suppress output</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;mpas_logger&quot;</span><span class="p">)</span>
    <span class="n">file_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="s1">&#39;mesh.log&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">file_handler</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>     

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building grid with jigsaw...&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">build_spherical_mesh</span><span class="p">(</span><span class="n">cellWidth</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">out_filename</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">grid_file</span><span class="p">),</span> <span class="n">earth_radius</span><span class="o">=</span><span class="n">target</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">plot_cellWidth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error building grid with jigsaw. See mesh.log for details.&quot;</span><span class="p">)</span>
        <span class="k">raise</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">orig_dir</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>

    <span class="c1"># Create the attribute dictionary that will enable the grid to be identified in case it needs to be regridded </span>
    <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">grid_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">assign_attrs</span><span class="p">(</span><span class="n">pix</span><span class="o">=</span><span class="n">pix</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">)</span> 

    <span class="c1"># Create a temporary file</span>
    <span class="n">temp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Write to the temporary file</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">temp_file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># Replace the original file only if writing succeeded</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">temp_file</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">grid_file</span><span class="p">)</span>    

    <span class="k">return</span> 
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h2 id="cratermaker.core.surface.initialize_surface" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">initialize_surface</span><span class="p">(</span><span class="n">make_new_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Initialize a Surface object with specified parameters and directory structure.</p>
<p>This function creates necessary directories, generates grid and surface DEM if required,
and initializes a Surface object with the loaded data.</p>
<h4 id="cratermaker.core.surface.initialize_surface--parameters">Parameters</h4>
<p>make_new_grid : bool, default False
    If True, generate a new grid.
reset_surface : bool, default True
    If True, reset the surface data.
pix : FloatLike | None, optional
    Pixel size or resolution of the grid.
target : Target | str | None, optional
    The target body for the surface, either as a Target object or a string name.
<em>args
    Variable length argument list for additional parameters.
</em>*kwargs
    Arbitrary keyword arguments.</p>
<h4 id="cratermaker.core.surface.initialize_surface--returns">Returns</h4>
<p>Surface
    An initialized Surface object.</p>
<h4 id="cratermaker.core.surface.initialize_surface--raises">Raises</h4>
<p>ValueError
    If the provided target name is invalid.
TypeError
    If the target is neither a Target instance nor a valid string name.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">initialize_surface</span><span class="p">(</span><span class="n">make_new_grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
         <span class="n">reset_surface</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
         <span class="n">pix</span><span class="p">:</span> <span class="n">FloatLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">target</span><span class="p">:</span> <span class="n">Target</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">simdir</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Surface</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize a Surface object with specified parameters and directory structure.</span>

<span class="sd">    This function creates necessary directories, generates grid and surface DEM if required,</span>
<span class="sd">    and initializes a Surface object with the loaded data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    make_new_grid : bool, default False</span>
<span class="sd">        If True, generate a new grid.</span>
<span class="sd">    reset_surface : bool, default True</span>
<span class="sd">        If True, reset the surface data.</span>
<span class="sd">    pix : FloatLike | None, optional</span>
<span class="sd">        Pixel size or resolution of the grid.</span>
<span class="sd">    target : Target | str | None, optional</span>
<span class="sd">        The target body for the surface, either as a Target object or a string name.</span>
<span class="sd">    *args</span>
<span class="sd">        Variable length argument list for additional parameters.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Arbitrary keyword arguments.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Surface</span>
<span class="sd">        An initialized Surface object.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the provided target name is invalid.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the target is neither a Target instance nor a valid string name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">simdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">simdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">Target</span><span class="p">(</span><span class="s2">&quot;Moon&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">Target</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid target name </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Target</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;target must be an instance of Target or a valid name of a target body&quot;</span><span class="p">)</span>

    <span class="c1"># Verify directory structure exists and create it if not</span>
    <span class="n">grid_temp_dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">simdir</span><span class="p">,</span> <span class="n">_GRID_TEMP_DIR</span><span class="p">)</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">grid_temp_dir_path</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">grid_temp_dir_path</span><span class="p">)</span>

    <span class="n">data_dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">simdir</span><span class="p">,</span> <span class="n">_DATA_DIR</span><span class="p">)</span>     
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">data_dir_path</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">data_dir_path</span><span class="p">)</span>

    <span class="n">grid_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir_path</span><span class="p">,</span><span class="n">_GRID_FILE_NAME</span><span class="p">)</span>

    <span class="c1"># Check to see if the grid is correct for this particular set of parameters. If not, then delete it and regrid</span>
    <span class="n">make_new_grid</span> <span class="o">=</span> <span class="n">make_new_grid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">grid_file_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">make_new_grid</span><span class="p">:</span>
        <span class="n">uxgrid</span> <span class="o">=</span> <span class="n">uxr</span><span class="o">.</span><span class="n">open_grid</span><span class="p">(</span><span class="n">grid_file_path</span><span class="p">)</span> 
        <span class="k">if</span> <span class="s2">&quot;pix&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uxgrid</span><span class="o">.</span><span class="n">parsed_attrs</span> <span class="ow">or</span> <span class="n">uxgrid</span><span class="o">.</span><span class="n">parsed_attrs</span><span class="p">[</span><span class="s2">&quot;pix&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pix</span><span class="p">:</span>
            <span class="n">make_new_grid</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="s2">&quot;grid_type&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uxgrid</span><span class="o">.</span><span class="n">parsed_attrs</span> <span class="ow">or</span> <span class="n">uxgrid</span><span class="o">.</span><span class="n">parsed_attrs</span><span class="p">[</span><span class="s2">&quot;grid_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span> <span class="c1"># this will need to be updated when other grid types are added</span>
            <span class="n">make_new_grid</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">make_new_grid</span><span class="p">:</span>
        <span class="n">reset_surface</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">generate_grid</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                      <span class="n">pix</span><span class="o">=</span><span class="n">pix</span><span class="p">,</span>
                      <span class="n">grid_file</span><span class="o">=</span><span class="n">grid_file_path</span><span class="p">,</span>
                      <span class="n">grid_temp_dir</span><span class="o">=</span><span class="n">grid_temp_dir_path</span><span class="p">)</span>

    <span class="c1"># Now redo the elevation data files if necessary </span>
    <span class="n">elevation_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir_path</span><span class="p">,</span><span class="n">_ELEVATION_FILE_NAME</span><span class="p">)</span>

    <span class="c1"># Load the grid and data files</span>
    <span class="n">data_file_list</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir_path</span><span class="p">,</span> <span class="s2">&quot;*.nc&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">grid_file_path</span> <span class="ow">in</span> <span class="n">data_file_list</span><span class="p">:</span>
        <span class="n">data_file_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">grid_file_path</span><span class="p">)</span>

    <span class="c1"># Generate a new surface if either it is explicitly requested via parameter or a data file doesn&#39;t yet exist </span>
    <span class="n">reset_surface</span> <span class="o">=</span> <span class="n">reset_surface</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">elevation_file_path</span><span class="p">)</span> <span class="ow">or</span> <span class="n">make_new_grid</span>  

    <span class="c1"># If reset_surface is True, delete all data files except the grid file </span>
    <span class="k">if</span> <span class="n">reset_surface</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">data_file_list</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">data_file_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">generate_data</span><span class="p">(</span><span class="n">grid_file</span><span class="o">=</span><span class="n">grid_file_path</span><span class="p">,</span>
                      <span class="n">data_file</span><span class="o">=</span><span class="n">elevation_file_path</span><span class="p">,</span>
                      <span class="n">name</span><span class="o">=</span><span class="s2">&quot;elevation&quot;</span><span class="p">,</span>
                      <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;elevation of nodes&quot;</span><span class="p">,</span>
                      <span class="n">save_to_file</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">isfacedata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="p">)</span>

    <span class="k">if</span> <span class="n">elevation_file_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_file_list</span><span class="p">:</span>
        <span class="n">data_file_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elevation_file_path</span><span class="p">)</span>

    <span class="c1"># Initialize UxDataset with the loaded data</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">uxr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="p">(</span><span class="n">grid_file_path</span><span class="p">,</span> <span class="n">data_file_list</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_dual</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error loading grid and data files&quot;</span><span class="p">)</span>
    <span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span><span class="n">uxgrid</span><span class="o">=</span><span class="n">surf</span><span class="o">.</span><span class="n">uxgrid</span><span class="p">,</span><span class="n">source_datasets</span><span class="o">=</span><span class="n">surf</span><span class="o">.</span><span class="n">source_datasets</span><span class="p">)</span> 

    <span class="n">surf</span><span class="o">.</span><span class="n">grid_temp_dir</span> <span class="o">=</span> <span class="n">grid_temp_dir_path</span>
    <span class="n">surf</span><span class="o">.</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">data_dir_path</span>
    <span class="n">surf</span><span class="o">.</span><span class="n">grid_file</span> <span class="o">=</span> <span class="n">grid_file_path</span>
    <span class="n">surf</span><span class="o">.</span><span class="n">elevation_file</span> <span class="o">=</span> <span class="n">elevation_file_path</span>
    <span class="n">surf</span><span class="o">.</span><span class="n">target_radius</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">radius</span>

    <span class="k">return</span> <span class="n">surf</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>


<div class="doc doc-object doc-function">




<h2 id="cratermaker.core.surface.save_surface" class="doc doc-heading">
          <code class="highlight language-python"><span class="n">save_surface</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">combine_data_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Save the surface data to the specified directory. Each data variable is saved to a separate NetCDF file.</p>
<h4 id="cratermaker.core.surface.save_surface--parameters">Parameters</h4>
<p>surface : Surface
    The surface object to be saved. 
out_dir : str, optional
    Directory to save the surface data. If None, the data is saved to the current working directory.</p>

          <details class="quote">
            <summary>Source code in <code>cratermaker/core/surface.py</code></summary>
            <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">save_surface</span><span class="p">(</span><span class="n">surf</span><span class="p">:</span> <span class="n">Surface</span><span class="p">,</span> 
                 <span class="n">out_dir</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">combine_data_files</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> 
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save the surface data to the specified directory. Each data variable is saved to a separate NetCDF file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface : Surface</span>
<span class="sd">        The surface object to be saved. </span>
<span class="sd">    out_dir : str, optional</span>
<span class="sd">        Directory to save the surface data. If None, the data is saved to the current working directory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">data_dir</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out_dir</span><span class="p">)</span>         

    <span class="n">surf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">combine_data_files</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">temp_dir</span><span class="p">:</span>
            <span class="n">outpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="n">_COMBINED_DATA_FILE_NAME</span><span class="p">)</span>
            <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_DIM_MAP</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">surf</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_DIM_MAP</span><span class="p">}</span>
            <span class="n">surf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">outpath</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">outpath</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">_COMBINED_DATA_FILE_NAME</span><span class="p">))</span> 
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">temp_dir</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">surf</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="n">dim_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_DIM_MAP</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">surf</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_DIM_MAP</span><span class="p">}</span>  <span class="c1"># only map dimensions that are in the variable</span>
                <span class="n">outname</span> <span class="o">=</span> <span class="n">var</span> <span class="o">+</span> <span class="s2">&quot;.nc&quot;</span> 
                <span class="n">outpath</span> <span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">,</span> <span class="n">outname</span><span class="p">)</span>
                <span class="n">surf</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">dim_map</span><span class="p">)</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">outpath</span><span class="p">)</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">outpath</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">outname</span><span class="p">))</span>

    <span class="k">return</span>
</code></pre></div></td></tr></table></div>
          </details>
  </div>

</div>



  </div>

  </div>

</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/jquery-3.6.0.min.js"></script>
        <script src="../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
